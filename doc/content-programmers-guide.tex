\include{header}
\newcommand{\version}{0.3.6}
\newcommand{\documentname}{\refprogrammersguide}


\begin{document}

\include{titlepage}

\renewcommand{\contentsname}{Contents}
\tableofcontents
\bigskip

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% todo
% !List of features and intended use-cases (zduvodneni featur FE)
	% rrequirements - functional, intraface, non-functional?


% release proces
% issues redmine - debugging & spol
% FE
  % FE - popsat, že to je webová aplikace, dá se spouštět pod tomcatem, odkaz na install manual
  % uncommitted tabulky

	% třídy
		% webfrontend.behavior - Wicket Behavior implementations
		% webfrontend.bo
		% webfrontend.configuration
		% webfrontend.core
			% DaoLookupFactory, ODCSWebFrontendApplicatoin .java/properties, ODCSWebFrontendSession, URLRouter
		% webfrontend.core.components - custom Wicket components (buttons, labels, form components etc.)
		% webfrontend.core.model - Wicket models and data providers
		% webfrotend.dao
		% webfrontend.pages - pages, panels, ...
		% webfrontend.util
		% webfrontend.validators

	% naming conventions

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\odcs is a~server application for management of Linked Data written in Java. It stores data in RDF, processes them and provides integrated views on the data.

This document serves as the main documentation for developers. It describes basic architecture, implementation, development process, used technologies and other important information relevant for people who want to participate in the development of \odcs.

\section{What is ODCleanStore}
\odcs accepts arbitrary RDF data and metadata through a SOAP webservice (\term{Input Webservice}). The data is processed by \term{transformers} in one of a~set of customizable \term{pipelines} and stored to a~persistent store (OpenLink Virtuoso database instance). The stored data can be accessed again either  directly through a SPARQL endpoint or through \term{Output Webservice}. Linked Data consumers can send queries and custom query policies to Output Webservice and receive (aggregated/integrated) RDF data relevant for their query, together with information about provenance and data quality. 

\section{Related documents}
More detailed information about \odcs from the perspective of a user or an administrator can be found in related documents \quot{\refusermanual} and \quot{\refadminmanual}. \refusermanual also contains definition of user roles, glossary of terms etc.

Other working documents related to development are located at the project's page at SourceForge\footnote{\url{https://sourceforge.net/p/odcleanstore/wiki/For\%20developers/}}. The Wiki tool at SourceForge is used for working documents, discussion of new features, description of testing scenarios etc. Not all pages are up-to-date, however, and this document is authoritative in case of conflicts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Requirements}
% todo
% features, interfaces, administration, future use
% motivace, ostatní existující řešení, v čem je to nové


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ODCleanStore overview} 
An overview of how \odcs works is depicted on \figurename~\ref{fig:odcsInternal}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{images/odcs-internal.png}
    \caption{Overview of ODCleanStore architecture}
	\label{fig:odcsInternal}
\end{figure}

The diagram lists all main functional units in \odcs:

\begin{itemize}
	\item \importantterm{Engine.}
		Engine runs the whole server part. It realizes all data processing and starts Input and Output Webservices.

		\begin{itemize}
			\item \importantterm{Input Webservice}. SOAP webservice that accepts new data and queues them for processing in the dirty database.
			\item Pipeline processing. Processes queued data by running a series of transformers in a pipeline on it and moves the dat to the clean database.
			\item \importantterm{Ouptut Webservice}. REST webservice for querying over data in the clean database.
		\end{itemize}
	\item \importantterm{Query Execution \& Conflict Resolution.}
		\QE retrieves all data and metadata relevant for a query asked via Output Webservice. Conflict Resolution then resolves conflicts in the retrieved data, including resolution of \code{owl:sameAs} links.
	\item Predefined transformers.
		Transformers used for data processing that are included by default in \odcs.
		\begin{itemize}
			\item \importantterm{Quality Assessment}. Estimates quality of data based on user-defined or generated rules.
			\item \importantterm{Data Normalization}. Transformations of data based on user-defined or generated rules.
			\item \importantterm{Linker}. Generates links (e.g. \code{owl:sameAs}) between resources in the processed data and contents of the clean database.
			\item Other transformers -- Other transformers such as Quality Aggregator, Blank Node Remover etc.
		\end{itemize}
	\item \importantterm{Administration Frontend.}
		Web application written in Java from which \odcs can be managed. In \FE, the user can define pipelines for data processing, rules for transformers, manage ontologies, Output Webservice settings etc.
\end{itemize}

Each of these parts will be described later in this document. In the source code, the components are divided into several maven projects described in Section \ref{sec:mavenBuild}.

\section{Important concepts}
\odcs is about data. More specifically, it works with data represented in RDF\footnote{\url{http://www.w3.org/TR/2004/REC-rdf-primer-20040210/}}. \odcs implements three tasks regarding data:

\begin{enumerate}
	\item Data processing
	\item Storing data
	\item Querying over stored data
\end{enumerate}

\subsection{Data Processing}
\label{sec:dataProcessing}
Data processing is realized by \term{transformers} that are applied to data being processed by Engine in a \term{pipeline}. A transformer can be any class implementing the \code{Transformer} interface but typically it only manipulates (change, add, delete) processed data in database. Several transformers ship with \odcs, such as \QA, \OI or \DN.

It is important to distinct between a \term{transformer} and \term{transformer instance}. By \term{transformer}, we mean the Java class which implements the \code{Transformer} interface and is registered in ODCleanStore administration (managed by users in role Administrator). \term{Transformer instance} is assignment of such transformer to a pipeline. For example, the \QA transformer is registered in ODCleanStore by default. The user can create two pipelines and assign the \QA transformer to each of them, thus creating two transformer instances.

Some transformers can be configured in \FE by \term{rules}. In general, these rules are grouped to \term{rule groups}. Rule groups can be then assigned to transformer instances.

See also Section \ref{sec:dataLifecycle} \nameref{sec:dataLifecycle}.

\subsection{Storing Data}
Data are stored using Open Link Virtuoso RDF database. Two instances of this database are used for every deployment of \odcs:

\begin{itemize}
	\item \term{Dirty (staging) database} -- contains data that are currently being processed. Contents of this instance is not directly visible for data consumers (users in role USR).
	\item \term{Clean database} -- contains already processed data that are accessible through the Output Webservice to data consumers (users in role USR).
\end{itemize}

\subsection{Querying over Stored Data}
Querying over stored data is realized by Output Webservice which supports several types of queries (see \refusermanual). For retrieval of results and resolving conflicts, Output Webservice uses components \QE (Section \ref{sec:QE}) and Conflict Resolution (Section \ref{sec:CR}).

\subsection*{}

See also Glossary in Appendix \ref{chap:glossary} for explanation of important concepts.

\section{Data Lifecycle}
\label{sec:dataLifecycle}

The lifecycle of data inside \odcs is as follows:

\begin{enumerate}
  \item RDF data (and additional metadata) are accepted by Input Webservice and stored as a~named graph to the {dirty database}. Data can be uploaded by any third-party application registered in \odcs.
  \item Engine successively processes named graphs in the dirty database by applying a~pipeline of transformers to it; the applied pipeline is selected according to the input metadata.
  \item Each transformer in the pipeline may modify the named graph or attach new related named graphs (such as a named graph with mappings to other resources or results of quality assessment).
  \item When the pipeline finishes, the augmented RDF data are populated to the {clean database} together with any auxiliary data and metadata created during the pipeline execution.
  \item Data consumers can use Output Webservice to query data in the clean database. Output Webservice provides several basic types of queries -- URI query, keyword and named graph query; in addition, metadata about a~given named graph can be requested. The response to a~query consists of relevant RDF triples together with their provenance information and quality estimate. The query can be further customized by user-defined conflict resolution policies.\\
	Data in the clean database can be also queried using the SPARQL query language. While SPARQL queries are more expressive, there is no direct support for provenance tracking and quality estimation. 
  \item When transformer rules change, the administrator may choose to re-run a~pipeline on data already stored in the clean database. Copy of this data is created in the dirty database where it is processed by the pipeline. After that, the processed version of data replaces the original in the clean database.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
\section{Architecture}

\subsection{Architecture Evolution}
The architecture that is depicted on \figurename~\ref{fig:odcsInternal} was chosen for several reasons.

First, the division into components is natural with regard to the original specification of the software project. All important components are included and we have also kept other concepts, such as two dataspaces for clean and dirty data, or the flexibility of data-processing pipeline.

Second, the selected architecture allowed a clear division of work and enabled a relative independence of each component.

Third, it is a result of a long process of analysis. From the initial vision and  requirements specification, which suggested an abstract concept of tranformers run in arbitrary order on data, we extracted several most important cases of transformers that were tightly bound to the system and could run only in a fixed order, only to generalize them back to transformers with a~very simple interface and flexible pipelines.


\subsection{Architectural Features}

\subsubsection{Components}
\odcs consists of several components that are (mostly) loosely-coupled only through a simple interface specified in advance. This made it easy divide tasks among developers and enabled them to work independently.

\subsubsection{Internal Interfaces}
In order to minimize interfaces between parts of \odcs, to minimize system requirements and to make the system more robust, we decided to prefer communication through data shared in database.

There is no direct interface between Engine and \FE, but the \FE saves all configuration to a relational database from which the Engine can retrieve it. This enbles updates of settings in transactions, prevents synchronization issues and enables the two parts to run completely independendently (even on separate machines).

Transformers run in a pipeline are isolated and don't know about each other. Instead of passing data to be transformed through an interface in memory, only the names of named graphs where data are stored are passed to each transformer. This enables to write transformers that are oblivious to \odcs as much as possible and only need to work with data by manipulating the database. Also, it gives transformers the full power of the SPARQL/SPARUL language. Although we should note that in practice, the transformer implementation may be tied with the use of Virtuoso as the underlying database, this is not such a downside because Virtuoso is one of the most popular RDF databases.

\subsubsection{Extensibility}
The main point of extensibility are custom transformers (see Section \ref{sec:customTransformers}). Because one only needs to implement a simple interface and is not bound to any specific technology (except of the limitations of the underlying Virtuoso database), transformers provide a very powerful way how to extend data processing capabilities.

\subsubsection{Interoperability}
The external interfaces are implemented using standard technologies (SOAP for Input Webservice, REST for Output Webservice) and standard formats (RDF/XML, Turtle/Notation3). This should minimize the effort for integration with third-party applications communicating with \odcs. We also provide a Java library for accessing the Input Webservice to futher minimize the effort.

\subsubsection{Used Technologies}
The choice of Java for implementation and Virtuoso as the underlying database ensure platform independence.

Since Java is a very wide-spread language, \odcs can be extended with minimum effort for learning new technologies (e.g. when adding new transformers).

\subsubsection{Scalability}
 Although currently the Engine is processing data sequentially, it is designed for parallel processing in the future. It could even be extended to work in a distributed manner on several machines.

 Most of the work the Input Webservice has is with data processing in pipelines. Since pipelines can run independently, each Engine instance could even use a dedicated database instance for dirty data.

 On the other hand, the Output Webservices uses the clean database in a read-only manner and thus could be also deployed on several database instances if database replication is put in place.

\section{Other requirements}
The assignment of the project impose several additional requirements. This section lists how they were satisfied.

\reqparagraph{It should be easy to incorporate other components, such as a component computing popularity of the data sources.} This requirement is satisfied with the introduction of custom transformers.

\reqparagraph{The application will involve graphical user interface enabling management of all kinds of policies etc.} \FE enables management of all relevant settings. In addition, several user roles are supported and user accounts can be managed from \FE.

\reqparagraph{The application will run at least on Windows 7, Windows Server 2008, Linux.} \odcs requires Java Runtime Environment and Virtuoso installation, both supported on all of the listed platforms. \odcs has been tested on Windows 7, Windows Server 2008 and Debian distribution of Linux.

\reqparagraph{Application will be freely available under Apache Software License.} \odcs is published under the required license (see \refadminmanual) and source codes available at a public repository at SourceForge.net

\section{Used technologies}

\subsection{Implementation Language}
The chosen language for implementation is Java. The reason is that there are many libraries and tools required for implemenation accessible in Java, it enables platform independence (one of the requirements on \odcs) and also it is very wide-spread so that developers don't need to learn a new syntax.

\subsection{Database}
Openlink Virtuoso\footnote{\url{http://virtuoso.openlinksw.com/}} is used as the underlying data store. It is the most popular RDF storage with a solid support. Both a commercial version and Open Source edition\footnote{\url{http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/}} exists.

RDF data store provided by Virtuoso supports reasoning, most notably \code{owl:sameAs} link resolution, which proved essential for Query Execution/Conflict Resolution components. Virtuoso also provides a relational database which relieves us from the need of another database for that purpose.

The downside is somewhat buggy behavior (especially SPARQL query parsing) and lack of working support for transactions with RDF data.

\subsection{Administration Frontend}
Apache Wicket\footnote{\url{http://wicket.apache.org/}} is used for implemenation of the \FE. It is a component system for writing web applications in Java. Advantages are proper mark-up and logic separation, POJO data model and rapid development of this particular type of web application. Wicket was also chosen by our sister project Strigil\footnote{\url{http://strigil.sourceforge.net/}} so a more tight integration of the two tools may be possible in the future.

Spring\footnote{\url{http://www.springsource.org/}} is used for simplified access to the relational database and transaction management. Use of Hibernate\footnote{\url{http://www.hibernate.org/}} for the DAO layer was rejected because of problems with integration with Wicket.

\subsection{Libraries}
\subsubsection*{Jena}
Apache Jena\footnote{\url{http://jena.sourceforge.net/}} is a library for manipulation with RDF data. It supports represenation of RDF data in memory, parsing, loading and updating of RDF models. In \odcs, it is used mainly for representation of RDF triples (quads) and serialization of RDF, because other features proved problematic when used with large data.

We chose Jena over its alternative Sesame\footnote{\url{http://www.openrdf.org/}} because it supports working with named graphs through NG4J and we had previous experience with it.

\subsubsection*{NG4J}
NG4J\footnote{\url{http://wifo5-03.informatik.uni-mannheim.de/bizer/ng4j/}} extends Jena with named graphs API.

\subsubsection*{Restlet}
Restlet\footnote{\url{http://www.restlet.org}} is an open source lightweight RESTful web framework for Java. Output Webservice is built on Restlet.

\subsubsection*{SLF4J}
SLF4J\footnote{\url{http://www.slf4j.org/}} is a flexible and efficient library used for logging. 

\subsection{Development tools}
\subsubsection*{Maven}
Apache Maven\footnote{\url{http://maven.apache.org/}} is used as the build tool. It was chosen over Apache Ant because Maven saves work with its many available plugins (such as Maven Jetty Plugin) and offers simple management of dependencies.

\subsubsection*{Git}
Git is used as the version control system. We used it because it enables simple manipulation with branches and merging but most importantly it is less dependent on a central server whose potential unavailability was identified as a potential risk.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Setting up Development Environment}

\section{Quick Start}
\subsection{Tools}
	In order to to prepare environment for building \odcs, first make sure to have installed all necessary tools:

\begin{itemize}
	\item Java Development Kit\footnote{\url{www.oracle.com/technetwork/java/javase/downloads/}} version 6 or newer
	\item Git version control system\footnote{\url{http://git-scm.com/}}
	\item Apache Maven\footnote{\url{http://maven.apache.org/}}
\end{itemize}

Also, make sure you have all the binaries used in the following steps on your classpath. 

\subsection{Obtaining sources} 
\odcs sources are hosted at SourceForge.\footnote{\url{http://sourceforge.net/p/odcleanstore/code/}} Use git to check out the sources:

\begin{verbatim}
      git clone git://git.code.sf.net/p/odcleanstore/code odcleanstore-code
\end{verbatim}

The above command will create a local clone of the repository in \code{odcleanstore-code} directory.

\subsection{Building binaries}
Move to directory \code{odcleanstore} within your local clone of the repository which contains the root maven project (\code{pom.xml}). Then build the project using maven:

\begin{verbatim}
      cd odcleanstore-code/odcleanstore
      mvn clean package install
\end{verbatim}

After that, Engine binaries can be found in directory \code{odcleanstore/engine/target} and the WAR file of \FE at \code{odcleanstore/webfrontend/target}. Now you can deploy the application as described in \refadminmanual. \todo{jestli tam bude jenom popis instalatoru, mel by se rucni deploy popsat tady a pridat referenci na instalaci Virtuosa}

\section{Repository structure}
\subsection{Branches}
There are several branches in the git repository. The latest development version of is on branch \code{master}. Then there are release branches for each release named \code{release-0.1.x}, \code{release-0.2.x} etc. which contain stable versions for  releases  packages. Each commit that where used to prepeare a release package is labeled with a tag \code{release}-\varcode{version}. Finally, there are feature branches prefixed with \code{feature-}.

Common development takes place on branch \code{master}. New feature branches are created for features that may or may not be accepted or that need time to be finished before they are applied to \code{master}. When whey are finished, they are merged to \code{master} and the branch may be removed in time. Release branches stem from \code{master} for every new major release. Fixes and modifications for minor releases take place on release branches and may be merged from/to \code{master}.

\subsection{Directory structure}
This is an outline of directory structure in the git repository:

\begin{dirlist}
	\item[data/] \mbox{}
		\begin{dirlist}
			\item[initial\_db\_import/] -- database import files
				\begin{dirlist}
					\item[clean\_db/] -- SQL files to be imported to the clean database
					\item[dirty\_db/] -- SQL files to be imported to the dirty database
				\end{dirlist}
			\item[odcs\_configuration/] -- the default \odcs configuration file
			\item[virtuoso\_configuration/] -- configuration files for Virtuoso database instances
		\end{dirlist}
	\item[doc/] -- documentation sources (in \LaTeX)
	\item[odcleanstore/] -- Java sources
		\begin{dirlist}
			\item[backend/] -- sources of \code{odcs-backend} artifact (transformers, Query Execution, Conflict Resolution)
			\item[comlib/] -- sources of \code{odcs-comlib} artifact (code related to sending data to Input Webservice)
			\item[conf/] -- configuration files for development in Eclipse
			\item[core/] -- sources of \code{odcs-core} artifact (common code shared by other artifacts)
			\item[engine/]  -- sources of \code{odcs-engine} artifact (Engine component)
			\item[inputclient/]  -- sources of \code{odcs-imputclient} artifact (Java client for Input Webservice)
			\item[simplescraper/]  -- simple Input Webservice import tool
			\item[simpletransformer/]  -- example of a custom transformer
			\item[webfrontend/]  -- sources of \FE
			\item[pom.xml] -- the root maven POM file
		\end{dirlist}
\end{dirlist}


\section{Maven build}
\label{sec:mavenBuild}
The project is divided into several artifacts. The root POM (\code{pom.xml}) in \code{odcleanstore} directory defines the parent project while each component of \odcs is in a separate artifact in subdirectories of \code{odcleanstore}. These artifacts are:

\begin{itemize}
	\item \code{odcs-core} -- common code shared by other artifacts; also defines interfaces for custom transformers
	\item \code{odcs-backend} -- predefined transformers, Query Execution and Conflict Resolution
	\item \code{odcs-engine} -- Engine component (running Input and Output Webservice and the data processing queue)
	\item \code{odcs-comlib} -- components shared by \code{odcs-inputclient} and Input Webservice
	\item \code{odcs-webfrontend} -- \FE web application
	\item \code{odcs-inputclient} -- client library for Input Webservice (provides a Java API for accessing the webservice)
	\item \code{odcs-simplescraper} -- a simple command-line tool for importing data through Input Webservices
	\item \code{odcs-simpletransformer} -- example of a custom transformer
\end{itemize}


It is recommended to always build using the root POM. Building from subprojects may require issuing \code{mvn install} on the root POM first. The entire project can be build with the following command:

\begin{verbatim}
      cd odcleanstore-code/odcleanstore
      mvn clean package
\end{verbatim}

There are two profiles in addition to the default one in the root POM.

\begin{itemize}
	\item \code{javadoc} profile -- enables generation of javadoc (which is disabled in the default profile). 
	\item \code{systest} profile -- enables unit tests in \code{systest/} subdirectories, which test functionality related to the database. In order to run these tests, a new Virtuoso instance with settings as in \code{/data/virtuoso\_configuration/virtuoso.ini-test} must be set up first.
\end{itemize}

Maven build for the selected profile can be executed with command line option \code{-P}:

\begin{verbatim}
      mvn clean package -P javadoc
      mvn clean package -P systest	
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Shared Code}
Code shared by multiple components in \odcs is extracted to Maven artifact \code{odcs-core}. It contains:

\begin{itemize}
	\item Classes for accessing configuration from the global configuration class.

		Java package: \code{cz.cuni.mff.odcleanstore.configuration}
	\item Helper classes for accessing the Virtuoso database.

		Java package: \code{cz.cuni.mff.odcleanstore.connection}

	\item Helper classes for imports of data to Virtuoso database from files.

		Java package: \code{cz.cuni.mff.odcleanstore.data}

	\item Classes related to transformer interface.

		Java package: \code{cz.cuni.mff.odcleanstore.transformer}

	\item Definitions of vocabularies used in \odcs.

		Java package: \code{cz.cuni.mff.odcleanstore.vocabulary}

	\item And other utility and helper classes, such as unique URI generators, filesystem utilities etc.
\end{itemize}

\section{Configuration}
The global configuration can be accessed using static methods of \code{ConfigLoader}. First, the configuration must be loaded using \code{loadConfig()} methods. Both Engine and \FE ensure that this is done as soon as they start so that other components may access the configuration already when they are loaded. See \refadminmanual for description of the configuration file.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.8\textwidth]{images/dia-core-config.png}
    \caption{Diagram of (selected) configuration classes}
	\label{fig:configurationClasses}
\end{figure}

Configuration for each component is in classes called \code{XXXConfig} inheriting from \code{ConfigGroup}. Each instance of \code{ConfigGroup} loads configuration relevant only for that component so as to minimize dependencies. Configurations for all components are grouped in \code{Config} class accessible from \code{ConfigLoader}.

\section{Database Access}
Classes \code{JDBCConnectionCredentials} and \code{SparqlEndpointConnectionCredentials} are containers for information necessary for connecting to the database.

\FE uses its own database access layer using Spring templates. The rest of \odcs should use classes \code{VirtuosoConnectionWrapper} and \code{WrappedResultSet}. These two classes provide methods for both querying and updating the relational database and working with SPARQL. They also provide methods for conversion of Virtuoso SQL types to Java types, working with transactions etc. Note that SPARQL update operations should be executed with log level set to AUTOCOMMIT (default).

Use of \code{VirtuosoConnectionWrapper} is also recommended for implementation of custom transformers. An example of how it can be used is in  \lstlistingname~\ref{lst:virtuosoConnectionWrapper}.

\begin{lstlisting}[caption={Example of programmatic access to Virtuoso database from a transformer},label=lst:virtuosoConnectionWrapper]

  @Override
  public void transformGraph(TransformedGraph inputGraph, TransformationContext context)
      throws TransformerException {
    VirtuosoConnectionWrapper connection = null;
    WrappedResultSet resultSet = null;
    try {
      connection = VirtuosoConnectionWrapper.createConnection(
          context.getDirtyDatabaseCredentials());

      String query1 = "SPARQL SELECT ?s WHERE {?s ?p ?o}";
      resultSet = connection.executeSelect(query1)
      while (resultSet.next()) {
        String s = resultSet.getString("s");
      }

      String query2 = "SPARQL INSERT INTO <a> { <b> <c> <d> }";
      connection.execute(query2);
    } catch (DatabaseException e) {
      throw new TransformerException(e);
    } catch (SQLException e) {
      throw new TransformerException(e);
    } finally {
      if (resultSet != null) { resultSet.closeQuietly(); }
      if (connection != null) { connection.closeQuietly(); }
    }
  }
\end{lstlisting}

\section{Data Import}
When importing data to Virtuoso, one should use the \code{GraphLoader}  class or methods in \code{VirtuosoConnectionWrapper}. These make Virtuoso import the data itself. Other methods, such as using the Jena library may fail when used with too large data. Note that when importing from a file, it must be in directory listed in \code{DirsAllowed} directive of Virtuoso. See also \code{engine.clean\_import\_export\_dir} configuration option.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Engine}

\todo{jak se to spousti, vypina, celkova architektura}

\section{Pipeline Processing}

\section{Input Webservice}

\section{Output Webservice}
\subsection{Purpose}
Output Webservice is a RESTful webservices for queries over data in the clean database. More details about types of queries and request format are described in \refusermanual.

\subsection{Implementation}
Output Webservice is built on top of the Restlet library. \code{OutputWSService} started by Engine registers a Restlet application implemented by class \code{Root} which sets up URI routes and handlers for each type of query.

Each type of query is handled by a class inheriting from \code{QueryExecutorResourceBase} which in turn implements Restlet \code{ServerResource}. This base class loads necessary configuration and handles requests (methods annotated with Restlet \code{@Get} and \code{@Post} annotations) -- parses request parameters (as described in \refusermanual), delegates the execution to the abstract \code{execute()} method implemented in child classes and handles returning of a proper response in case of an error.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.7\textwidth]{images/dia-outputws-resources.png}
    \caption{Diagram of selected Output Webservice classes}
	\label{fig:outputwsResources}
\end{figure}


Classes implementing the actual execution of the query are \code{UriQueryExecutorResource}, \code{KeywordQueryExecutorResource}, \code{NamedGraphQueryExecutorResource} and \linebreak[4] \code{MetadataQueryExecutorResource}. They redefine the abstract \code{execute()} method where query-specific parameters are parsed and the execution is delegated to the Query Execution component. Instance of the \code{QueryExecution} class is shared between requests in order to utilize caching implemented in Query Execution. Finally, the result of the query is formatted and sent to the user.

\subsection{Output Formatters}
Query results returned from Query Execution are formatted using the format requested by the user. Formatting is done by classes implementing \code{QueryResultFormatter}.

The default formatter is \code{HTMLFormatter} which outputs results in HTML. \code{RDFXMLFormatter} and \code{TriGFormatter} inherit from \code{RDFFormatter} and output results in RDF/XML and TriG, respectively. \code{DebugFormatter} formats result for output to console and is not accessible for users.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.8\textwidth]{images/dia-outputws-formatters.png}
    \caption{Diagram of output formatters hierarchy}
	\label{fig:outputwsFormatters}
\end{figure}

\subsection{Extending}
In order to add a new type of query to Output Webservice, the following steps should be taken:

\begin{enumerate}
	\item Implement a new \code{ServerResource} executing the query, preferably inheriting from \linebreak[4] \code{QueryExecutorResourceBase}. Typically, the actual query will be delegated to the Query Execution component -- see Section \ref{sec:qeExtending}.
	\item Register the new \code{ServerResource} in method \code{Root\#createInboundRoot()}.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Query Execution}
\label{sec:QE}

\section{Purpose}
The purpose of \QE is to retrieve result for a query (asked through Input Webservice), resolve conflicts using the \CR and return result.

Triples that \QE retrieves are:
\begin{enumerate}
	\item \label{item:queryTriples} Triples relevant for the query (e.g. containing the given URI).
	\item Triples with metadata about named graphs containing triples from (\ref{item:queryTriples}).
	\item Triples containing human-readable labels for URI resources occuring in triples from (\ref{item:queryTriples}).
\end{enumerate}
A special case is the metadata query which retrieves only named graph metadata.

Because the result of conflict resolution depends on the data it is given, \QE and \CR are not independent but rather \QE extracts exactly the data that \CR needs and calls it directly.

\section{Interface}
The public interface of the \QE component is represented by class \code{QueryExecution}.

 This class exposes methods for executing all kinds of supported queries and returns result as an instance of \code{MetadataQueryResult} (wraps collection of provenance metadata triples and other metadata) or \code{BasicQueryResult} (wraps collection of \code{CRQuad}s returned from \CR plus metadata). The query can be further parametrized by passing \code{QueryConstraintSpec} and \code{AggregationSpec} affecting the retrieved data and the conflict resolution process, respectively.

 \code{QueryExecution} is thread-safe and its instance should be kept between requests in order to effectively utilize caching.

\section{Implementation}
The actual implementation is in classes inheriting from \code{QueryExecutorBase}, each implementing one type of query: \code{URIQueryExecutor}, \code{KeywordQueryExecutor}, \code{NamedGraphQueryExecutor} and \code{MetadataQueryExecutor}. These classes are called internally from the \code{QueryExecution} class. Implementing classes are in Java package \code{cz.cuni.mff.odcleanstore.queryexecution}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.8\textwidth]{images/dia-qe.png}
    \caption{Diagram of main Query Execution classes}
	\label{fig:qeClasses}
\end{figure}

For each query, the following steps are executed: input is validated, result quads retrieved from the database, metadata and labels are retrieved from the database and conflict resolution is applied to the result.

To improve performance, values that are used for each query but rarely changed are cached. Cached values are: default aggregation settings, prefix mappings and label properties.

\section{Extending}
\label{sec:qeExtending}
In order to implement a new type of query, the following steps should be taken:

\begin{enumerate}
	\item Create a class implementating the new query, preferably inheriting from \code{QueryExecutorBase}.
	\item Extend \code{QueryExecution} class with method for executing the query.
	\item Extend Input Webservice to provide access to the new query for users.
\end{enumerate}

\section{Database}
\QE retrieves RDF data from the clean database instance. Because Virtuoso doesn't fully support transactions with RDF data, the clean database may contain incomplete data partially inserted by Engine. In order to filter such data from the result, \QE ignores all named graphs whose URI starts with an agreed prefix\footnote{\code{http://opendata.cz/infrastructure/odcleanstore/internal/hiddenGraph/}} given by Engine to such named graphs.

In addition, \QE loads settings from the following tables in relational database (see Appendix \ref{chap:reldb}):

\begin{itemize}
	\item \dbodcs{qe\_label\_properties}
	\item \dbodcs{cr\_properties} 
	\item \dbodcs{cr\_settings} 
	\item and tables referenced from tables above
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conflict Resolution}
\label{sec:CR}

\section{Purpose}
Data stored in \odcs may come from multiple sources and conflicting statements may emerge. For example, data about a city stored in \odcs may state multiple different values for its population. The purpose of \CR is to resolve such conflicts according to default or user-defined policies (e.g. show the latest, average or all values for the population). In addition, it computes an estimate of \aggrq of each RDF triple in the resulting data and provides provenance tracking, 	i.e. provides URIs and metadata of named graphs from which the resulting value was selected or calculated from. Finally, \CR can filter out old versions of data for which a newer version was inserted.

\todo{}

\section{Interface}
Interface of the \CR component is represented by Java interface \code{ConflictResolver}. It contains a single operation:
\begin{verbatim}
      Collection<CRQuad> resolveConflicts(Collection<Quad> quads)
          throws ConflictResolutionException;
\end{verbatim}
\CR accepts a collection of quads (RDF triple + named graph) and returns a collection of \code{CRQuad}s (quad + \aggrq + source named graphs).

An instance of \code{ConflictResolver} can be obtained from factory class \code{ConflictResolverFactory}. Constructor of this class takes query-independent settings and its \code{createResolver()} methods takes query-dependent settings (named graph metadata, sameAs links, aggregation settings, preferred URIs) and returns a new instance of \code{ConflictResolver} for these settings.

\section{Implementation}
The actual implementation of the \code{ConflictResolver} interface is in class \code{ConflictResolverImpl}. Its constructor requires two parameters -- one of type \code{ConflictResolverSpec} contains all settings for conflict resolution and one of type \code{ConflictResolutionConfig} is a container for global settings (configurable in the \odcs configuration file). \code{ConflictResolverSpec} contains default and per-property aggregation methods to be used, metadata of relevant named graphs including \QA scores, additional \code{owl:sameAs} links to consider and other technical settings.

Implementation of the \code{resolveConflicts()} methods does the following:

\begin{enumerate}
	\item \code{owl:sameAs} links are used to find resources representing the same entity. The implementation is in class \code{URIMappingImpl} which uses the DFU (Disjoint Find and Union) data structure with path compression to find weakly connected components of the \code{owl:sameAs} links graph.
	\item URI resources in input quads are translated so that a single URI is used for every resource representing the same entity using mapping created in the previous step.
	\item The resulting quads are sorted and grouped to clusters of (potentially) \term{conflicting quads}, i.e. those sharing the same subject and predicate. Implemented in \code{ResolveQuadCollection}.
	\item \CR iterates over groups of conflicting quads and applies the actual conflict resolution procedure.
		\begin{enumerate}
			\item The next group of conflicting quads is retrieved. All such quads have the same value in place of the subject and predicate.
			\item If there are Identical triples which come from named graphs where one named graph is an update of the other named graphs, the old versions are removed (see Section \ref{sec:latestUpdateMarker} for definition of an update).
			\item An aggregation method is chosen based on the predicate of quads in the current group and conflict resolution settings.
			\item \label{item:crAggr}
				The aggregation method is applied to the current group of conflicting quads. The output is a collection of \code{CRQuad}s and it is added to the result.
		\end{enumerate}
	\item The resulting \code{CRQuad}s are returned.
\end{enumerate}

We call steps 1-3 \term{implicit conflict resolution} and it doesn't depend on the given aggregation settings. It prepares input data for step 4 so that result quads and \aggrq can be computed independently on chosen resource URIs. Its time complexity is $\mathcal{O}(S \log S + N \log N)$ where $S$ is the number of \code{owl:sameAs} links and $N$ number of input quads. Step 4 is applied to sets of conflicting quads having the same subject and predicate so the context of aggregation is given mainly by quad objects.

\subsection{Aggregation Methods}
\CR accepts an argument of type \code{ConflictResolverSpec} which specifies which agregation method should be used for which predicate, among other things. This is set either by the user as a parameter of Output Webservice or a default setting in \odcs is used.
The selected aggregation method determines how conflicts are resolved and \aggrq of the result is computed in step \ref{item:crAggr} of the conflict resolution algorithm.

An aggregation method is represented by Java interface \code{AggregationMethod} with the following method:

\begin{verbatim}
      Collection<CRQuad> aggregate(
          Collection<Quad> conflictingQuads, 
          NamedGraphMetadataMap metadata);
\end{verbatim}

Objects implementing \code{AggregationMethod} are created by \code{AggregationMethodFactory}. Classes implementing an aggregation method inherit from \code{AggregationMethodBase} and their hierarchy is depicted on \figurename~\ref{fig:crAggregations}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{images/dia-cr-aggregations.png}
    \caption{Implementation classes of aggregation methods}
	\label{fig:crAggregations}
\end{figure}

There are two basic types of aggregations. First type called \term{selected aggregations} selects one or more quads from input quads while the result of the second type called \term{calculated aggregation} returns values computed from all the input quads (e.g. average). The common functionality of these two types is in abstract classes \code{CalculatedValueAggregation} and \code{SelectedValueAggregation}.

A special type of selected aggregation is \code{BestSelectedAggregation} which selects a single best quad based on a metric given as an instance of \code{AggregationComparator} (\figurename~\ref{fig:crComparators}).

As an optimization, if there is only a single quad in a group of conflicting quads, a special optimized \code{SingleValueAggregation} aggregation can be used because all aggregation methods should return the same result in this case.

If the selected aggregation method cannot be applied to a value (e.g. average of a string literal), the behavior depends on the given aggregaiton error strategy - the value may be either discarded, or included in the result without aggregation applied.

More details about each aggregation method and their time complexity can be found in javadoc of the respective classes.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{images/dia-cr-comparators.png}
    \caption{Comparators for \code{BestSelectedAggregation}}
	\label{fig:crComparators}
\end{figure}
	
\subsection{Quality and Provenance calculation}
The aggregation methods described in the previous section solve conflicts by calculating or selecting values in place of the object of a quad (e.g. choose the quad with the highest \QA score, the latest insertion date, maximum value in place of the object, or calculate the average of all values in place of the object). In addition, they add provenance and quality information.

The provenance information consists of a list of named graphs, let us denote them \term{source named graphs}, from which the result was selected or calculated from. For calculated aggregations, these are named graphs of all aggregated quads, for selected aggregations these are named graphs containing the quad(s) selected to the result.

The \aggrq estimate is done for each result quad and is based on several factors based on real-world scenarios: quality scores of the source named graphs, number of graphs that agree on a value and the difference between a value and other (conflicting) values.

\subsubsection{Notation}
An aggregation method works on quads having the same subject and predicate and they may only differ in the object and the named graph. Let $n$ be the number of aggregated quads (in a single group of conflicting quads). Let $o_i$ be the value in place of object and $g_i$ the named graph of $i$-th quad.

Let $s_{ng}(g)$ denote the \QA score of a named graph $g$ and $s_p(g)$ the average score of publishers of the named graphs. Both these values are given in named graph metadata as input of conflict resolution (they are computed in advance by \QA and Quality Aggregator transformers, respectively). $s(g)$  denotes the total score of a named graph based on $s_{ng}(g)$ and $s_p(g)$ (see Section~\ref{sec:qualityCalculation}).

Let $agree(v)$ denote the set of named graphs that agree on the value $v$, i.e. $$agree(v) = \left\{g_i~|~v_i=v\right\}.$$

Finally let $q(v)$ denote the \aggrq of a result quad that has value $v$ as its object.

\subsubsection{Constraints on Quality Calculation}
The algorithm calculating \aggrq was designed so that several constraints hold:
\begin{itemize}
	\item If $n= 1$, then $q(v_1) = s(g_1)$.
	\item If there is a named graph $g$ asserting a non-conflicting value $v$, the quality (based just on the value $v$) should be at least $s(g)$.
	\item $q(v)$ is increasing with \QA scores of source named graphs of quads having $v$ as object.
	\item $q(v)$ is decreasing with increasing difference from other object values in input quads, taking their \QA scores into consideration (higher \QA score means higher weight of the value).
	\item If multiple source named graphs agree on the same value $v$, then $q(v)$ is increased.
	\item If $k$ sources with \QA scores equal to 1 (highest score) claim a value completely different from value $v$, then quality of $v$ should be decreased approximately $k$ times. If the sources have lower \QA scores, the decrease should be lower.
\end{itemize}

\subsubsection{Quality Calculation}
\label{sec:qualityCalculation}
Aggregate quality $q(v)$ is calculated in the following steps:
\begin{enumerate}
	\item A total \QA score $s(g)$ for each source named graph is determined. It is calculated as
		$$s(g) = \alpha s_{ng}(g) + (1-\alpha) s_p(g),$$

		where $\alpha\in[0,1]$ is a configurable parameter.
	\item Quality based on source named graphs is calculated. For each quad object value $v$, we compute quality based on source named graphs, let us denote it $q_1(v)$.

		$$q_1(v) = \begin{cases}
				\mathrm{avg} \left\{s(g)~|~g\in \left\{g_1,\ldots,g_n\right\}	\right\} & \mbox{calculated aggregations} \\
				\max \left\{s(g)~|~g\in agree(v)\right\} & \mbox{selected aggregations}
			\end{cases} $$
	\item Next, the differences between conflicting values are taken into consideration. We use a metric $d:U\times U\rightarrow[0,1]$ satisfying $d(v,v)=0$ for this purpose.

		We use $d(x,y)=|(x-y) / \mathrm{avg}(x,y)|$ in case of numeric literals, normalized Levenshtein distance in case of string literals, difference divided by a configurable maximum value in case of dates and $d(x,y)=1$, where $x\neq y$, for URI resources, blank nodes and nodes of incompatible types.

		Whether decreasing the aggregate quality based on conflicting values is the right solution depends on context, however. Predicate \code{rdf:type} often has multiple valid values which are not in fact conflicting. Therefore, whether to decrease score based on conflicts is set by the \term{multivalue} setting for the current predicate.
		
		If multivalue is false and there are conflicting values different from $v$, the  quality of $v$ is reduced increasingly with the value of metric $d$ and the score of the source of the conflicting value:

		$$q_2(v) = \begin{cases}
				q_1(v) \cdot \left(1- \frac{\sum_{i=1}^{n}s(g_i)d(v,v_i)}{\sum_{i=1}^ns(g_i)}\right) & \mbox{multivalue is false for the current property}\\
				q_1(v) & \mbox{multivalue is true for the current property} 
			\end{cases}
		$$
		
	\item Aggregate quality should be increased if multiple values agree on the same value.
		$$q_3(v) = q_2(v)+(1-q_2(v))\cdot \min \left(\frac{-q_1(v)+\sum_{g\in agree(v)} s(g)}{C}, 1\right),$$
		where $C\in\mathbb{N}$ is a configurable constant.
	\item Each aggregation method may adjust the general algorithm. In case of the CONCAT aggregation, computing $q_2$ and $q_3$ doesn't make sense and $q(v)=q_1(v)$ is returned. AVG and MEDIAN aggregations return $q(v)=q_2(v)$, and finally $q(v)=q_3(v)$ is returned for other aggregations.
\end{enumerate}

\subsubsection{Time Complexity}
\label{aggrTimeComplexity}
The time complexity of the \aggrq computation for a fixed value $v$ is $\mathcal{O}(n\cdot D)$, where $D$ is the complexity of the distance metric evaluation. This gives us the overall complexity of $\mathcal{O} (n^2 \cdot D)$ for ALL and BEST aggregations, $\mathcal{O}(n \log n + n \cdot D$ for MEDIAN and $\mathcal{O}(n\cdot D)$ for others.

\section{Time Complexity}
Let $N$ be the total number of input quads of the conflict resolution process, $S$ number of \code{owl:sameAs} links, $G$ number of named graphs for which we have metadata given. Let $CQ=\left\{cq_1, cq_2, \ldots, cq_K\right\}$ be the set of groups of conflicting quads and $n_i=|cq_i|$ be the size of $i$-th group of conflicting quads. $D$ is the complexity of distance metric evaluation.

The complexity of implicit conflict resolution algorithm is $\mathcal{O}(N \log N + S\log S)$. Grouping the quads into clusters of conflicting quads requires sorting in $\mathcal{O}(N \log N)$, assuming comparison of two RDF nodes is in constant time. Filtering of old versions is implemented in $\mathcal{O}(n_i \log n_i \log G)$ (\code{NamedGraphMetadataMap} is implemented using a \code{TreeMap}, could be improved to $\mathcal{O}(n_i\log n_i)$ with a \code{HashMap}). Finally an aggregation method is applied with complexity given in Section \ref{aggrTimeComplexity}.

To sum up, the total time complexity is:
\begin{itemize}
	\item In case of ALL and BEST aggregation:
		$$ \mathcal{O}\left(N \log N + S\log S + \sum_{i=1}^K \left(n_i \log n_i \log G + n_i^2 D\right)\right)$$
	\item For aggregations other than ALL, BEST and MEDIAN:
	$$ \mathcal{O}\left(N \log N + S\log S + \sum_{i=1}^K \left(n_i \log n_i \log G + n_i D\right)\right)$$
\end{itemize}

In the worst case when $K = 1$ and $G = N$ ($G\leq N$ because at most $N$ named graphs can be among input quads and \CR gets in fact metadata only for these named graphs), this gives us

\begin{itemize}
	\item In case of ALL and BEST aggregation:
		$$ \mathcal{O}\left(N^2 D+S\log S\right)$$
	\item For aggregations other than ALL, BEST and MEDIAN:
	$$ \mathcal{O}\left( N \log^2 N + ND+S\log S \right)$$
\end{itemize}

Distance metric is evaluated in linear time for strings (modified Levenshtein distance) and in constant time for other cases.

\section{Extending}
In order to add a new aggregation method, the following steps should be taken:
\begin{enumerate}
	\item Implement the aggregation in a class implementing the \code{AggregationMethod} interface.
	\item Create a constant representing this aggregation method in enum \code{EnumAggregationType}.
	\item Extend \code{AggregationMethodFactory} to create an instance of the new aggregation.
\end{enumerate}

If a new distance metric for a specific type of literal is to be added, this should be done in the \code{DistanceMetricImpl} class.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Transformers -- Introduction}
In this section, by a transformer we mean a Java class implementing the \code{Transformer} interface shown in \lstlistingname~\ref{lst:transformer} (and other related classes used for implementation).

\begin{lstlisting}[caption={Transformer interface},label=lst:transformer]
  package cz.cuni.mff.odcleanstore.transformer;
  public interface Transformer {
    void transformGraph(TransformedGraph inputGraph, TransformationContext context)
         throws TransformerException;

    void shutdown() throws TransformerException;
}
\end{lstlisting}

The purpose of a transformer is to somehow process data. The data are not passed in memory, but rather stored in the (dirty) database instance and only the URI of the named graph to be processed and connection credentials for accessing the database are given to the transformer. This should minimize the need of complicated interfaces for data passing, make it easier to work with large data, let the transformer choose its own method of accessing the database and give it the full power of SPARQL/SPARUL (as implemented in Virtuoso).

The actual data processing should be implemented in the \code{transformGraph()} method. All required information is passed in its arguments, one with information about the processed graph and one about the environment -- see \lstlistingname{}s~\ref{lst:transformedGraph} and \ref{lst:transformationContext}.

The \code{shutdown} method is called when Engine shuts down and can be used e.g. to release acquired resources.

\begin{lstlisting}[caption={TransformedGraph interface},label=lst:transformedGraph]
  package cz.cuni.mff.odcleanstore.transformer;
  import java.util.Collection;

  public interface TransformedGraph {
    String getGraphName();
    String getGraphId();
    String getMetadataGraphName();
    String getProvenanceMetadataGraphName();
    Collection<String> getAttachedGraphNames();
    void addAttachedGraph(String attachedGraphName) throws TransformedGraphException;
    void deleteGraph() throws TransformedGraphException;
    boolean isDeleted();
  }
\end{lstlisting}

\begin{lstlisting}[caption={TransformationContext interface},label=lst:transformationContext]
  package cz.cuni.mff.odcleanstore.transformer;
  import java.io.File;
  import cz.cuni.mff.odcleanstore.connection.JDBCConnectionCredentials;

  public interface TransformationContext {
    JDBCConnectionCredentials getDirtyDatabaseCredentials();
    JDBCConnectionCredentials getCleanDatabaseCredentials();
    String getTransformerConfiguration();
    File getTransformerDirectory();
    EnumTransformationType getTransformationType(); /* NEW or EXISTING */
  }
\end{lstlisting}

\section{Transformer Instance Configuration}
Each instance of a transformer in a pipeline may have its own configuration (for explanation of the difference between \term{transformer} and \term{transformer instance}, see Section \ref{sec:dataProcessing}). From the point of view of a transformer, it is a plain string which can be obtained by calling the \code{getTransformerConfiguration()} method.

This configuration string can be edited in \FE. The transformer may use the value in any way it needs, e.g. it may contain XML configuration, the recommended practice is to use the Java \code{Properties} file format, however. This format is used by transformers included by default in \odcs unless stated otherwise.

Instances of important transformers (\QA, \DN, \OI) can be also configured by assigning rule groups to them in \FE.

\section{Contract between Engine and Transformers}
\label{sec:transformerContract}
Although Virtuoso doesn't fully support transactions over RDF data, data processing in \odcs is implemented so as to keep data consistent. In order to make it work, however, a contract between Engine and transformers must be satisfied.

The Engine ensures that:

\begin{itemize}
	\item When a transformer is applied to a transformed graph, no other transformer (in the same nor different pipeline) is applied to it. In other words, the transformed graph is not changed externally while a transformer is working on it.
	\item If the transformer throws an exception, all changes made in the pipeline on the graph in the dirty database are safely reverted (and the state of the graph is changed to WRONG). The graph may be processed again later. If the transformer was run on a graph already in the clean database, the version in the clean database in intact.
	\item Transformers may use the directory given by the \code{getTransformerDirectory()} method for they own purposes, e.g. storing temporary files, log files etc. It is a subdirectory named as the ID of the executed transformer instance inside the \quot{working directory} of the transformer (configurable in \FE).

		Data specific for one transformer instance may be stored in this directory. Data shared by all instances of the same transformer may be stored in the parent directory of that returned by \code{getTransformerDirectory()}. Engine ensures that this parent directory will be the same for all instances of the same transformer (unless working directory is changed in \FE, of course).
\end{itemize}

In return, transformers should satisfy:

\begin{itemize}
  \item Transformers may add/update/delete data in the \code{payload} graph, metadata graph, \code{provenance} graph or attached graphs. It may also add data to new graphs, but the transformer must
		\begin{enumerate}
			\item register the graph by calling \code{addAttachedGraph()} \textit{before} it writes any data to it,
			\item make sure that the name of the new graph is unique in the database (transformer may use the \code{getGraphId()} method to create names unique for each named graph).
		\end{enumerate}
		Transformers shouldn't modify contents of the dirty database in any other way.
	\item Transformers may access the clean database, but should use it only for reading. Because other transformer in the pipeline may fail, the changes executed by the current transformer in the dirty database may be discarded but changes in the clean database would be kept which may cause inconsistencies. The same applies should the transformer execute any other persistent actions.
	\item Transformer should only use the directory given by \code{getTransformerDirectory()} or its parent directory for accessing the filesystem.
\end{itemize}

\section{Custom Transformers}
\label{sec:customTransformers}
The administrator may extend data-processing capabilities of \odcs by adding new custom transformers. How to do so is described in \refadminmanual.

From the technical point of view, a transformer implementation must implement the \code{Transformer} interface. This interface and other necessary classes are included in maven artifact \code{odcs-core}, so that only this artifact need to be referenced.

Note that custom transformers should satisfy conditions listed in Section \ref{sec:transformerContract}.

\chapter{Transformers included in ODCleanStore}

\section{Quality Assessment \& Quality Aggregator}
\section{Data Normalization}
\section{Linker}
\section{Other Transformers}
\subsection{Blank Node Remover}
Blank Node Remover is a simple transformer for replacing of blank nodes in the \code{payload} graph with unique URI resources. It is implemened in class \code{ODCSBNodeToResourceTransformer}.

The generated URIs have format {\varcode{prefix}\varcode{random UUID}-\varcode{Virtuoso nodeID}}. The transformer guarantees that occurrences of the same blank node within the transformed graph
 will be assigned the same URI, however, occurrences of the blank node in other graphs will be assigned a different URI when they are processed by the transformer.

Value of \code{input\_ws.named\_graphs\_prefix} configuration option concatenated with \quot{genResource/} is used as the default value of the \varcode{prefix} part. It can be overriden by \code{uriPrefix} option in transformer instance configuration.

\subsubsection{Configuration}
Possible configuration options for an instance of this transformer:
\begin{configlist}
	\item[uriPrefix] Sets the prefix of URIs generated in place of blank nodes.
\end{configlist}

\subsection{Latest Update Marker}
\label{sec:latestUpdateMarker}
Latest Update Marker is an internal transformer for marking the latest version of a named graph with \code{odcs:isLatestUpdate} property. The marker may be used when accessing the clean database directly through the SPARQL endpoint. Latest Update Marker is implemented in class \code{ODCSLatestUpdateMarkerTransformer}.

A named graph $A$ is considered an update of named graph $B$ if:
\begin{enumerate}
		\item Named graphs $A$ and $B$ have the same update tag, or both have an unspecified (\code{null}) update tag.
	  \item Named graphs $A$ and $B$ were inserted by the same (SCR) user.
	  \item Named graphs $A$ and $B$ have the same set of sources in metadata.
\end{enumerate}

The transformed graph will be labeled as the latest version by adding  the triple\linebreak \varcode{payload-graph}-\code{odcs:isLatestUpdate}-\quot{1}. If it updates another graph in the clean database, the other graph will be unmarked as being the latest version.

This transformer is automatically added by Engine to the end of every pipeline. This is neccessary because the transformer may modify the clean database and therefore should ensure that the pipeline won't fail afterwards.

\subsection{Property Filter}
Property Filter is an internal transformer for filtering of properties used internally by \odcs from input data. It is implemented in class \code{ODCSPropertyFilterTransformer}.

Property Filter simply removes all triples that have any of the filtered URIs in place of the predicate (see Input Processing in \refusermanual{}) from the \code{payload} and \code{provenance} named graphs.

This transformer is automatically added by Engine as the first transformer of every pipeline.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Administration Frontend}
\section{Purpose}
\section{Interface}
\section{Implementation}

\subsection{Database Access Layer}
\FE has a layer for accessing the database based on Spring and its JDBC templates. We chose not to use Hibernate due to integration problems with Wicket and use custom implemenation of business and DAO objects.

Entities retrieved from database are represented by POJOs (Plain Old Java Objects). The code that actually retrieves them is in a DAO class, by convention having suffix \code{Dao} and inheriting from the base class \code{Dao}. DAO objects internally call methods of the Spring's \code{JdbcTemplate} and passes to it a class extending \code{CustomRowMapper} which implements creation of the POJO business object(s) from query results.

The DAO objects can be obtained from an instance of \code{DaoLookupFactory} (available e.g. as a protected member of \code{FrontendPage}). A DAO object can be obtained by calling a \code{getDao()} method which returns an existing DAO object or creates a new one if necessary. Signatures of \code{getDao()} methods are:

\begin{verbatim}
  public <T extends Dao> T getDao(Class<T> daoClass)
  public <T extends Dao> T getDao(Class<T> daoClass, boolean commitable)
\end{verbatim}

We utilize generics in Java to obtain a specific type of a DAO class. In addition, there may be two versions of a DAO class -- one for a read-only view of commited version of an entity and one for the working version visible only to the author (see Section \ref{sec:authorshipAuth}). One can use the second version of the \code{getDao()} method and request either the read-only or commitable version.

Commitable and read-only DAOs are implemented using a custom \code{@CommitableDao} annotation. The read-only version should be annotated with \code{@CommitableDao} having the commitable DAO class as its argument. The commitable version must inherit from the read-only DAO.

Hierarchy of DAO objects is depicted on \figurename~\ref{fig:feDAO}.

\begin{figure}[htb]
    \centering
    \includegraphics[width=1.05\textwidth]{images/dia-fe-dao.png}
    \caption{Selected DAO classes used in \FE}
	\label{fig:feDAO}
\end{figure}

\subsubsection{Important DAO Classes}
Description of the most important DAO classes follows:

\begin{description}[style=nextline,font=\ttfamily]
	\item[Dao] This is the base class of all DAO classes. It keeps an instance of \code{JdbcTemplate} and provides access to it either directly or through utility methods \code{jdbcQuery()}, \code{jdbcQueryForInt()}, \code{jdbcQueryForList()}, etc. It can also execute code in a Spring transaction with \code{executeInTransaction()} and handles proper recognition of some exceptions thrown by Virtuoso JDBC driver.
	\item[DaoTemplate] This method provides convenience methods for loading of one or more entities from the database. Its \code{getTableName()}, \code{getRowMapper()}, \code{getSelectAndFromClause()}, \code{postLoadAllBy()} and \code{postLoadBy()} methods can be used to customize the loading. Other methods are declared as final.
	\item[DaoForEntityWithSurrogateKey] This DAO is used for working with entities with a primary key. The corresponding business objects must inherit from \code{EntityWithSurrogateKey}. It extends \code{DaoTemplate} with additional methods for loading, deleting and saving an entity by its primary key.
	\item[DaoForAuthorableEntity] This class is intended for entities that can be edited only by their author. It adds an abstract method \code{getAuthorId()}.
	\item[AbstractRuleDao] Base class for (QA, DN, Linker) transformer rules. It provides methods for commiting of changes and disables any delete and update operations.
	\item[XXXRuleDao] Concrete classes inheriting from AbstractRuleDao. It can be used for read-only access to rules (their commited version, respectively). \code{save()} and \code{update()} methods throw an exception. It is annotated with \code{@CommittableDao(XXXRuleUncommittedDao.class)} so that the commitable/editable version can be obtained.

		An instance of this DAO may be obtained by calling e.g.\\
		\code{daoLookupFactory.getDao(XXXRuleDao, false)}.
	\item[XXXRuleUncommittedDao] These classes inherit from \code{XXXRuleDao} and provide the editable and commitable view on transformer rules. Changes may be commited in transaction by calling \code{commitChanges()}.

		An instance of this DAO may be obtained by calling e.g.\\
		\code{daoLookupFactory.getDao(XXXRuleDao, true)}.
\end{description}

\subsection{Authorization}
There are two main scopes of authorization in \odcs -- authorization based on roles and authorization based on the authorship of an entity.

\subsubsection{Roles}
Authorization based on roles recognizes 5 roles: Administrator (ADM), Pipeline Creator (PIC), Ontology Creator (ONC), Data Producer (SCR) and Data Consumer (USR). Their detailed description is given in \refusermanual. Roles can be assigned to users in \FE and a user can have any number of roles.

We use means provided by Wicket to apply authorization by role. Pages and components can be marked with \code{@AuthorizeInstantiation} annotation with enumeration of roles that are required to access the page or component (at least one of the roles from the given list is required). The roles assigned to the currently logged-in user are kept in the session object \code{ODCSWebFrontendSession} which extends Wicket \code{AuthenticatedWebSession} for this purpose.

\subsubsection{Authorship}
\label{sec:authorshipAuth}
Authorization based on authorship is necessary for entities that can be only edited by their author. Rule groups and rules, for example, can be only edited by the user who created them or by user having the role Administrator. To facilitate checking of whether the current user is authorized for entity editing, class \code{LimitedEditingPage} extending \code{FrontendPage} was introduced.

\code{LimitedEditingPage} requires two additinal arguments in its constructor: edited entity ID and a DAO class for the authorable entity (\code{DaoForAuthorableEntity}), which can retrieve author based on entity ID. It then checks whether the current user is authorized using a helper class \code{AuthorizationHelper} and makes this information accessible with protected methods.

Every page that needs information about whether the user is authorized for editation of can call protected methods \code{checkUnauthorizedInstantiation()} to prevent the user from displaying the page or \code{isEditable()} to detect whether the user is authorized for editation.

Because transformer rules and related settings must be commited before the changes are visible to  users not 
authorized for editation (who have a read-only access to rules), there are two versions of rules in the database -- one version is visible for the author and Administrators (these tables have suffix \code{\_UNCOMMITED}) and one version visible for Engine and other users. The proper table version for the current user can be obtained by method \code{getVisibleTableVersion()}.

\code{}

\section{Extending}

\subsection{How to Add a New Page}
\label{sec:howToAddANewPage}

First of all make sure that you are familiar with the Wicket framework, for the whole web application is based on it.

A standard Wicket \code{WebPage} component is used to create new pages. That means that you can use all the standard stuff that Wicket provides, such as adding standard child components (forms, tables, links, ...). Aditionaly, you should adhere to some specific conventions, which have been established to ease and fasten the development process and to make the web well structured and consistent. This section provides you with details on these conventions.

The POJO part of the page component should extend the \code{FrontendPage} class. The \code{FrontendPage} component provides page layout and content for parts of the page which are common throughout the whole application (such as logo and menu bar). That's why, when creating a new page, you only need to take care of the custom content. There are two components handled by the \code{FrontendPage} which need per-page parameters - the page title and the bread crumbs. The newly created page should supply these values via a call to the constructor of the parent's class. The \code{FrontendPage} also contains several helper factory methods which can be used to construct simple child components. Last but not least, the \code{FrontendPage} provides two shortcut methods - \code{getApp} to obtain the application object and \code{getODCSSession} to get the session object. All of these are protected scoped and can be used arbitrarily in new page components.

The POJO must provide a constructor. The constructor should be either parameter-less or accept a single parameter - the id of entity to be described on the page. Inside the constructor you generaly need to - call the parent's constructor (and suply the page title and crumbs values), obtain all needed DAO objects via the \code{daoLookupFactory} class attribute (see the section on the DAO layer) and add all child components, ideally through calls to private methods, one for each component.

You will also want to update the HTML file of the \code{FrontendPage} component in order to add a link to the new page to the menu bar. Simply add a new standard Wicket link to the HTML list.

All parts of the web frontend application adhere to the following structure rules. Every section describes registered entities of a single type (such as transformers, pipelines, ontologies, user accounts). For every entity type (say XXX) there are four page components - \code{XXXListPage} (shows a list of all registered entities), \code{NewXXXPage} (provides a form to register a new entity), \code{XXXDetailPage} (shows an existing entity in details and provides a form to edit it; if there are subentities bound to the entity then shows a list of all of them).

As a rule, every page should contain a single help pop-up window for every entity the user can work with via that page. To create a help pop-up window for a new entity type (say XXX again), you only need to create an XXXHelpPanel component (you can copy an existing help panel component and update the contents in the related HTML page). Then use the \code{addHelpWindow} method of the \code{FrontendPage} class to add the pop-up window to the page.


\subsection{How to Add a New \DN Template}

To add a new \DN Template (named say XXX, such as Filter, Rename, Replace), follow these steps.

Create a new relational table in the Virtuoso database. The table should be named \code{DB.ODCLEANSTORE.DN\_XXX\_TEMPLATE\_INSTANCES} and contain \code{id} as a surrogate primary key, \code{groupId} as a foreign key which points to the group of rules to which the template instance belongs, \code{rawRuleId} as a foreign key which points to the raw version of the represented rule and columns for attributes of the template.

Add a new Business Object to the \code{cz.cuni.mff.odcleanstore.webfrontend.bo.dn} package named \code{DNXXXTemplateInstance}. The class should adhere to standard BO conventions (see the relevant section) and relate to the table created in the previous step.

Add a compiler class to the same package called \code{DNXXXTemplateInstanceCompiler}. It must extend the \code{DNTemplateInstanceCompiler<DNXXXTemplateInstance>} class and override the \code{compile} method. This methods accepts an \code{DNXXXTemplateInstance} instance as a parameter and compiles it into a standard \code{CompiledDNRule} instance (e.g. into a raw rule form), which it then returns.

Add a new section to the \code{DNGroupDetailPage} component and implement the \code{NewDNXXXTemplateInstancePage} and \code{EditDNXXXTemplateInstancePage} components. You will also need to add the \code{DNXXXTemplateInstanceHelpPanel} and use it as a pop-up help window. Fore a more detailed explanation of this step, see section How to add a New Page.

Note that when implementing a new DN template type it is a good idea to copy and rename the classes which belong to an existing one and just overwrite the template specific parts.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{(Conclusion, evaluation)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{(Testing scenario)}
\todo{Do uzivatelskeho manualu?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{(Related Work)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Future Work}
\todo{plus known bugs?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\chapter{Glossary}
\label{chap:glossary}
\input{appendix-glossary}

%\chapter{ODCS ontology}

\chapter{Relational Database Schema}
\label{chap:reldb}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-engine.png}
    \caption{Diagrams of database tables related to Engine}
	\label{fig:dbEngine}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-pipelines.png}
    \caption{Diagrams of database tables related to pipelines}
	\label{fig:dbPipelines}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-fe.png}
    \caption{Diagrams of database tables related to \FE}
	\label{fig:dbFrontend}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-qa.png}
    \caption{Diagrams of database tables related to \QA}
	\label{fig:dbQA}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-dn.png}
    \caption{Diagrams of database tables related to \DN}
	\label{fig:dbDN}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-oi.png}
    \caption{Diagrams of database tables related to \OI}
	\label{fig:dbOI}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-cr.png}
    \caption{Diagrams of database tables related to \CR}
	\label{fig:dbCR}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.6]{images/db-misc.png}
    \caption{Diagrams of miscellaneous database tables}
	\label{fig:dbMisc}
\end{figure}

\chapter{(\quot{chronologicky popis prubehu praci na projektu})}

\chapter{Project organization}

\begin{itemize}
	\item Team, task division (Developer-Component-Main responsibilities)
	\item Meetings
	\item Release process (+ presentation)
	\item Remarks?
\end{itemize}

\end{document}
